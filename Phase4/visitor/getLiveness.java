//
// Generated by JTB 1.3.2
//

package visitor;
import syntaxtree.*;
import java.util.*;
import visitor.LiveRange;
import javax.sound.sampled.Line;

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */
class LRComparator implements Comparator<LiveRange>{
   public int compare(LiveRange lr1, LiveRange lr2)
   {
      return (lr1.start - lr2.start);
   }
}
public class getLiveness<R,A> implements GJVisitor<R,A> {
   //
   // Auto class visitors--probably don't need to be overridden.
   //
   public ArrayList<ProcInfo> procList = new ArrayList<ProcInfo>();
   public ArrayList<LineInfo> tempList = new ArrayList<LineInfo>();
   ProcInfo funCall_check = new ProcInfo();
   ArrayList<String> argList = new ArrayList<String>();
   int maxArgs = -1;
   public HashMap<String,Integer> LabelStart = new HashMap<String,Integer>();
   int lno = 0;
   int pno = 0;
   LineInfo currLine = new LineInfo();
   String currLabel = "";
   boolean isOutside = true;

   public String genArgStr(){
      int n = argList.size();
      maxArgs = Math.max(n, maxArgs);
      String ret = "";
      for(int i = 0; i < n ; i++){
         ret += "_"+argList.get(i);
      }
      return ret;
   }
   public ArrayList<ProcInfo> retProcs(){
      return procList;
   }
   public HashMap<String,Integer> retLabs(){
      return LabelStart;
   }
   public void printDebug(){
      System.out.println(LabelStart.toString() );
      for(ProcInfo p : procList){
         System.out.println("PNO:"+p.pno);
         System.out.println("NAME:"+p.name+" args:"+p.num_args);
         System.out.println(p.assignedReg.toString());
         for(LineInfo l: p.lineList){
            System.out.println("LNO:"+l.lno + " Label:"+l.label + " " + l.line);
            System.out.println(l.use.toString());
            System.out.println(l.def.toString());
            System.out.println(l.in.toString());
            System.out.println(l.out.toString());
         }
         for(LiveRange l: p.varInfo){
            l.printStuff();
         }
      }
   }
   public void printProcOnly(){
      System.out.println(LabelStart.toString() );
      for(ProcInfo p : procList){
         if(p.name == "Tree_SetHas_Left"){
            System.out.println("PNO:"+p.pno);
         System.out.println("NAME:"+p.name+" args:"+p.num_args);
         System.out.println(p.assignedReg.toString());
         for(LineInfo l: p.lineList){
            System.out.println("LNO:"+l.lno + " Label:"+l.label + " " + l.line);
            System.out.println(l.use.toString());
            System.out.println(l.def.toString());
            System.out.println(l.in.toString());
            System.out.println(l.out.toString());
         }
         for(LiveRange l: p.varInfo){
            l.printStuff();
         }
            break;
         }
      }
      
   }
   public void addEdges(ArrayList<LineInfo> l, int u, int v){
      l.get(u).succ.add(l.get(v));
      l.get(v).pred.add(l.get(u));
   }
   public void genEdges(){
      for(int i = 0; i < procList.size(); ++i){
         ProcInfo p = procList.get(i);
         ArrayList<LineInfo> l = p.lineList;
         for(int j = 0; j < l.size(); j++){
            String[] strList = l.get(j).line.split("_");
            if(strList[0].equals("JUMP")){
               int jumpNo = LabelStart.get(strList[1]);
               addEdges(l, j, jumpNo - p.base_lno);
            }
            else if(strList[0].equals("CJUMP")){
               int jumpNo = LabelStart.get(strList[2]);
               addEdges(l, j, jumpNo-p.base_lno);
               if(j != l.size()-1){
                  //Should always occur
                  addEdges(l, j, j+1);
               }
            }
            else {
               if(j != l.size()-1){
                  addEdges(l, j, j+1);
               }
            }

         }
      }
   }
   public void fillInOut(){
      boolean loop = true;
      while(loop){
         loop = false;
         for(int i = 0; i < procList.size(); ++i){
            ProcInfo p = procList.get(i);
            ArrayList<LineInfo> l = p.lineList;
            for(int j = 0; j < l.size(); j++){
               LineInfo currL = l.get(j);
               HashSet<String> newIn = new HashSet<String>();
               HashSet<String> newOut = new HashSet<String>();
               for(LineInfo succTemps:currL.succ){
                  newOut.addAll(succTemps.in);
               }
               if(!currL.out.containsAll(newOut)){
                  loop = true;
                  currL.out = newOut;
               }
               newIn.addAll(currL.use);
               newIn.addAll(currL.out);
               newIn.removeAll(currL.def);
               if(!currL.in.containsAll(newIn)){
                  loop = true;
                  currL.in = newIn; 
               }

            }
         }
      }
   }
   public void genLiveRanges(){
      for(int i = 0; i < procList.size(); ++i){
         ProcInfo p = procList.get(i);
         HashMap<String, Integer> startL = new HashMap<String, Integer>();
         HashMap<String, Integer> endL = new HashMap<String, Integer>();
         ArrayList<LineInfo> l = p.lineList;

         for(int j = 0; j < l.size(); ++j){
            LineInfo currL = l.get(j);
            HashSet<String> liveTemps = new HashSet<String>();
            liveTemps.addAll(currL.def);
            liveTemps.addAll(currL.in);
            for(String temp : liveTemps){
               if(!startL.containsKey(temp)){
                  startL.put(temp, currL.lno);
                  endL.put(temp, currL.lno);
               }
               else{
                  endL.put(temp, currL.lno);
               }
            }
         }

         for (Map.Entry elem : startL.entrySet()) {
            String tempName = (String)elem.getKey();
            int tempNo = Integer.parseInt(tempName.substring(4));
            int value = (int)elem.getValue();
            LiveRange tempRange = new LiveRange();
            tempRange.temp = tempName;
            tempRange.start = value;
            tempRange.end = endL.get(tempName);
            tempRange.tempNo = tempNo;
            if(tempNo < p.num_args){
               tempRange.isArg = true;
               if(tempNo < 4){
                  tempRange.argLoc = tempNo;
               }
               else{
                  tempRange.inStack = true;
               }
            }
            p.varInfo.add(tempRange);
         }
      }
   }
   public void allocation(ProcInfo p, ArrayList<LiveRange> sortedLiveRanges){
      TreeSet<String> freeRegs = new TreeSet<String>();
      ArrayList<LiveRange> active = new ArrayList<LiveRange>();
      int n = p.spill_base;
      for(int i = 0; i < 8; ++i){
         freeRegs.add("s"+Integer.toString(i));
         freeRegs.add("t"+Integer.toString(i));
      }
      freeRegs.add("t8");
      freeRegs.add("t9");
      for(LiveRange lr : sortedLiveRanges){
         expireOldIntervals(p,lr,freeRegs,active);
         if(active.size() == 18){
            n = spillAtInterval(p,lr,active,n);
         }
         else{
            String reg = freeRegs.pollFirst();
            //System.out.println(freeRegs.toString());
            p.assignedReg.put(lr.temp,reg);
            //System.out.println(active.size());

               int x = 0;
               for(x = 0; x < active.size(); ++x){
                  if(lr.end <= active.get(x).end){
                     break;
                  }
               }
               active.add(x,lr);
         }
         //System.out.println(p.assignedReg.toString());
         /*for(LiveRange ttt : active){
            ttt.printStuff();
         }
         System.out.println("bbbbbbbbbb");*/
      }

      p.stack_spc = n;
   }
   public void expireOldIntervals(ProcInfo p,LiveRange lr, TreeSet<String> freeRegs,ArrayList<LiveRange> active){
      for(int j = 0; j < active.size(); ++j){
         if(active.get(j).end > lr.start){
            break;
         }
         else if(active.get(j).end == lr.start){
            if((active.get(j).end == active.get(j).start)){
               break;
            }
         }
         String reg = p.assignedReg.get(active.get(j).temp);
         freeRegs.add(reg);
         active.remove(j);
      }
   }
   public int spillAtInterval(ProcInfo p, LiveRange i, ArrayList<LiveRange> active, int nextStackLoc){
      p.spilled = true;
      LiveRange spill = active.get(active.size()-1);
      int newStackLoc = nextStackLoc;
      if(spill.end > i.end){
         String reg = p.assignedReg.get(spill.temp);
         p.assignedReg.put(i.temp,reg);
         p.assignedReg.replace(spill.temp,"stack_" + Integer.toString(newStackLoc));
         spill.inStack = true;
         spill.stackLoc = newStackLoc;
         newStackLoc++;
         active.remove(active.size()-1);
         for(int j = 0; j < active.size(); ++j){
            if(i.end <= active.get(j).end){
               active.add(j,i);
               break;
            }
         }
      }
      else{
         i.inStack = true;
         i.stackLoc = newStackLoc;
         newStackLoc++;
      }
      return newStackLoc;
   }
   public void linearScan(){
      for(ProcInfo p : procList){
         int nextStackLoc = 0;
         p.extra_args = Math.max(0, p.num_args-4);
         ArrayList<LiveRange> LRList = new ArrayList<LiveRange>();
         for(LiveRange lr : p.varInfo){
            if(lr.isArg){
               if(lr.inStack){
                  lr.stackLoc = nextStackLoc;
                  p.assignedReg.put(lr.temp,"stack_" + Integer.toString(nextStackLoc));
                  nextStackLoc++;
               }
               else{
                  LRList.add(lr);
                  //p.assignedReg.put(lr.temp,"a"+Integer.toString(lr.argLoc));
               }
            }
            else{
               LRList.add(lr);
            }
         }
         if(p.name.equals("MAIN")){
            p.spill_base = nextStackLoc;
         }
         else{
               p.spill_base = 8+nextStackLoc;
         }
         Collections.sort(LRList, new LRComparator());
         
         /*for(LiveRange lr : LRList){
            lr.printStuff();
         }
         System.out.println("aaaaaaaaaa");*/
         allocation(p, LRList);
      }
   }
   public R visit(NodeList n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeListOptional n, A argu) {
      if ( n.present() ) {
         R _ret=null;
         int _count=0;
         for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
            e.nextElement().accept(this,argu);
            _count++;
         }
         return _ret;
      }
      else
         return null;
   }

   public R visit(NodeOptional n, A argu) {
      if ( n.present() )
         return n.node.accept(this,argu);
      else
         return null;
   }

   public R visit(NodeSequence n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeToken n, A argu) { return (R) n.tokenImage; }

   //
   // User-generated visitor methods below
   //

   /**
    * f0 -> "MAIN"
    * f1 -> StmtList()
    * f2 -> "END"
    * f3 -> ( Procedure() )*
    * f4 -> <EOF>
    */
   public R visit(Goal n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      ProcInfo p = new ProcInfo();
      p.name = "MAIN";
      p.num_args = 0;
      p.pno = pno;
      p.base_lno = 0;
      maxArgs = -1;
      funCall_check = p;
      n.f1.accept(this, argu);
      isOutside = false;
      p.lineList = tempList;
      if(maxArgs == -1 ){
         p.max_call = 0;
      }
      else{
         p.max_call = maxArgs;
      }
      procList.add(p);
      pno++;
      tempList = new ArrayList<LineInfo>();
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      genEdges();
      fillInOut();
      genLiveRanges();
      linearScan();
      //printDebug();
      //printProcOnly();
      return _ret;
   }

   /**
    * f0 -> ( ( Label() )? Stmt() )*
    */
   public R visit(StmtList n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Label()
    * f1 -> "["
    * f2 -> IntegerLiteral()
    * f3 -> "]"
    * f4 -> StmtExp()
    */
   public R visit(Procedure n, A argu) {
      R _ret=null;
      isOutside = false;
      String pname = (String)n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      int i = Integer.parseInt((String)n.f2.accept(this, argu));
      n.f3.accept(this, argu);

      ProcInfo p = new ProcInfo();
      p.pno = pno;
      p.num_args = i;
      p.name = pname;
      p.base_lno = lno;
      pno++;
      funCall_check = p;

      isOutside = true;
      maxArgs = -1;

      n.f4.accept(this, argu);

      
      if(maxArgs == -1){
         p.max_call = 0;
      }
      else{
         p.max_call = maxArgs;
      }
      p.lineList = tempList;
      procList.add(p);
      tempList = new ArrayList<LineInfo>();
      return _ret;
   }

   /**
    * f0 -> NoOpStmt()
    *       | ErrorStmt()
    *       | CJumpStmt()
    *       | JumpStmt()
    *       | HStoreStmt()
    *       | HLoadStmt()
    *       | MoveStmt()
    *       | PrintStmt()
    */
   public R visit(Stmt n, A argu) {
      R _ret=null;
      isOutside = false;
      LineInfo l = new LineInfo();
      l.lno = lno;
      lno++;
      l.label = currLabel;
      currLine = l;
      l.line = (String)n.f0.accept(this, argu);
      tempList.add(l);
      currLabel = "";
      isOutside = true;
      return _ret;
   }

   /**
    * f0 -> "NOOP"
    */
   public R visit(NoOpStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return (R)"NOOP";
   }

   /**
    * f0 -> "ERROR"
    */
   public R visit(ErrorStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return (R)"ERROR";
   }

   /**
    * f0 -> "CJUMP"
    * f1 -> Temp()
    * f2 -> Label()
    */
   public R visit(CJumpStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String t = (String)n.f1.accept(this, (A)"dontAdd");
      String l = (String)n.f2.accept(this, argu);
      currLine.use.add(t);
      return (R)("CJUMP_"+t+"_"+l);
   }

   /**
    * f0 -> "JUMP"
    * f1 -> Label()
    */
   public R visit(JumpStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String l = (String)n.f1.accept(this, argu);
      return (R)("JUMP_"+l);
   }

   /**
    * f0 -> "HSTORE"
    * f1 -> Temp()
    * f2 -> IntegerLiteral()
    * f3 -> Temp()
    */
   public R visit(HStoreStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String t1 = (String)n.f1.accept(this, (A)"dontAdd");
      String i = (String)n.f2.accept(this, argu);
      String t2 = (String)n.f3.accept(this, (A)"dontAdd");
      currLine.use.add(t2);
      currLine.use.add(t1);
      return (R)("HSTORE_"+t1+"_"+i+"_"+t2);
   }

   /**
    * f0 -> "HLOAD"
    * f1 -> Temp()
    * f2 -> Temp()
    * f3 -> IntegerLiteral()
    */
   public R visit(HLoadStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String t1 = (String)n.f1.accept(this, (A)"dontAdd");
      String t2 = (String)n.f2.accept(this, (A)"dontAdd");
      String i = (String)n.f3.accept(this, argu);
      currLine.use.add(t2);
      currLine.def.add(t1);
      return (R)("HLOAD_"+t1+"_"+t2+"_"+i);
   }

   /**
    * f0 -> "MOVE"
    * f1 -> Temp()
    * f2 -> Exp()
    */
   public R visit(MoveStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String t1 = (String)n.f1.accept(this, (A)"dontAdd");
      currLine.def.add(t1);
      String exp = (String)n.f2.accept(this, argu);
      return (R)("MOVE_"+t1+"_"+exp);
   }

   /**
    * f0 -> "PRINT"
    * f1 -> SimpleExp()
    */
   public R visit(PrintStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String exp = (String)n.f1.accept(this, argu);
      return (R)("PRINT_"+exp);
   }

   /**
    * f0 -> Call()
    *       | HAllocate()
    *       | BinOp()
    *       | SimpleExp()
    */
   public R visit(Exp n, A argu) {
      R _ret=null;
      String exp = (String)n.f0.accept(this, argu);
      return (R)exp;
   }

   /**
    * f0 -> "BEGIN"
    * f1 -> StmtList()
    * f2 -> "RETURN"
    * f3 -> SimpleExp()
    * f4 -> "END"
    */
   public R visit(StmtExp n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      isOutside = true;
      n.f1.accept(this, argu);
      isOutside = false;
      n.f2.accept(this, argu);
      LineInfo l = new LineInfo();
      l.lno = lno;
      lno++;
      currLine = l;
      String exp = (String)n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      l.line = "RETURN_"+exp;
      tempList.add(l);
      return _ret;
   }

   /**
    * f0 -> "CALL"
    * f1 -> SimpleExp()
    * f2 -> "("
    * f3 -> ( Temp() )*
    * f4 -> ")"
    */
   public R visit(Call n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String exp = (String)n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      argList = new ArrayList<String>();
      n.f3.accept(this, (A)"fromCall");
      String args = genArgStr();
      n.f4.accept(this, argu);
      funCall_check.fun_call = true;
      return (R)("CALL_"+exp+args);
   }

   /**
    * f0 -> "HALLOCATE"
    * f1 -> SimpleExp()
    */
   public R visit(HAllocate n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String exp = (String)n.f1.accept(this, argu);
      return (R)("HALLOCATE_"+exp);
   }

   /**
    * f0 -> Operator()
    * f1 -> Temp()
    * f2 -> SimpleExp()
    */
   public R visit(BinOp n, A argu) {
      R _ret=null;
      String op = (String)n.f0.accept(this, argu);
      String t = (String)n.f1.accept(this, argu);
      currLine.use.add(t);
      String se = (String)n.f2.accept(this, argu);
      return (R)(op+"_"+t+"_"+se);
   }

   /**
    * f0 -> "LE"
    *       | "NE"
    *       | "PLUS"
    *       | "MINUS"
    *       | "TIMES"
    *       | "DIV"
    */
   public R visit(Operator n, A argu) {
      R _ret=null;
      String op = (String)n.f0.accept(this, argu);
      return (R)(op);
   }

   /**
    * f0 -> Temp()
    *       | IntegerLiteral()
    *       | Label()
    */
   public R visit(SimpleExp n, A argu) {
      R _ret=null;
      String se = (String)n.f0.accept(this, argu);
      return (R)se;
   }

   /**
    * f0 -> "TEMP"
    * f1 -> IntegerLiteral()
    */
   public R visit(Temp n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String i = (String)n.f1.accept(this, argu);
      if(argu!=null){
         String s = (String)argu;
         if(s.equals("fromCall")){
            argList.add("TEMP"+i);
            currLine.use.add("TEMP"+i);  
         }
         else if(s.equals("dontAdd")){
            ;  
         }
      }
      else{
         currLine.use.add("TEMP"+i);
      }
      return (R)("TEMP"+i);
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   public R visit(IntegerLiteral n, A argu) {
      R _ret=null;
      String i = (String)n.f0.accept(this, argu);
      return (R)i;
   }

   /**
    * f0 -> <IDENTIFIER>
    */
   public R visit(Label n, A argu) {
      R _ret=null;
      String id = (String)n.f0.accept(this, argu);
      if(isOutside){
         currLabel = id;
         LabelStart.put(id, lno);
      }
      return (R)id;
   }

}
